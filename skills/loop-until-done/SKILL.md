---
name: loop-until-done
description: 通用迭代质量框架。**所有有交付产出任务的默认工作流**。理解需求 → 制定计划 → 执行 → 自检验证 → 发现缺口 → 继续迭代，直至完全满足需求。
---

# 迭代直到完成

## 概述

**这是所有有交付产出任务的默认工作流**。

迭代是你的基因——自检、发现缺口、继续改进，直到需求完全满足。这不是可选流程，而是刻在骨子里的工作方式。

### 核心循环

```
理解需求 → 制定计划 → 执行 → 自检验证 → 发现缺口
    ↑                                              |
    |____________________继续迭代___________________|
```

### 何时使用

**默认触发：**
- 任何有明确交付产出的任务
- 无论是代码、文档、设计、配置、脚本、分析报告等

**仅不触发：**
- 纯信息查询（"X 是什么"、"Y 怎么做"）
- 纯探索研究（无具体交付要求）

> **核心原则：** 有产出就迭代。一次完成的交付往往有缺口；迭代确保质量。

---

## 迭代协议

### 第零阶段：角色选择（CRITICAL）

**每项任务必须基于 2-4 个相关角色开展工作，避免单一视角盲区。**

1. **参考权威定义**：`rules/roles.md` 定义了完整的角色系统
   - 10 个可用角色：架构师、开发者、语言专家、评审者、产品、业务领域专家、QA、安全、Prompt 工程师、DevOps
   - 任务-角色映射表（开发功能、缺陷修复、代码评审等）
   - 输出格式：视角摘要 / 综合分析

2. **执行角色分析**：按 `rules/roles.md` 中的"如何应用角色"步骤进行
   - 步骤 1：选择角色（参考任务-角色映射）
   - 步骤 2：按角色视角分析
   - 步骤 3：综合输出（使用指定格式）

3. **关键规则**（来自 `rules/roles.md`）
   - 至少两个视角
   - 角色深度匹配
   - 代码变更必须包含语言专家
   - 用户指定角色优先

> **违规即失败：** 单一视角工作违反迭代协议，必须在开始前纠正。

---

### 第一阶段：理解需求

1. **重述请求**：用自己的话确认用户真正要什么
2. **选择角色**：确定 2-4 个相关角色，进行角色视角分析（见第零阶段）
3. **澄清缺口**：必要时使用 `brainstorming` 技能确保理解一致
4. **明确成功标准**：可验证的完成条件

**进入第二阶段前，确保你不会基于错误假设开始工作。**

### 第二阶段：制定计划

1. **分解任务**：将目标拆解为可执行步骤
2. **识别依赖**：哪些步骤必须先完成
3. **预估验证方式**：如何确认每步完成且正确

对于复杂任务，使用 `writing-plans` 技能创建结构化计划文档。

### 第三阶段：执行与验证

1. **按计划执行**：一次一个步骤，专注完成
2. **验证产出**：使用适合任务类型的验证方式
3. **记录进度**：标记完成项，列出剩余项

### 第四阶段：完成度检查

**每轮迭代后必须回答：**

| 检查项 | 说明 |
|--------|------|
| 交付物存在 | 产出是否已创建且可访问 |
| 需求覆盖 | 对照原始请求，是否全部满足 |
| 无已知缺口 | 是否有遗漏、缺陷或待改进项 |
| 无回归 | 是否引入了新问题（代码类） |
| 角色视角完整 | 是否已覆盖所有选定角色的关注点 |

**全部通过 → 停止；任一未通过 → 继续迭代**

---

## 验证方式（按任务类型）

| 任务类型 | 验证方式 |
|---------|----------|
| 代码 | 运行测试、手动验证、代码检查 |
| 文档 | 阅读检查、链接验证、示例可运行 |
| 配置 | 语法检查、加载测试、实际应用 |
| 分析/报告 | 数据验证、逻辑检查、结论可复现 |
| 设计 | 对照需求评审、完整性检查 |

**选择适合的验证方式，不要拘泥于"运行测试"这一种形式。**

---

## 迭代输出格式

每轮结束时按以下格式报告：

```markdown
## 迭代 N

### 本轮完成
- [x] 完成项 1
- [x] 完成项 2

### 验证结果
[粘贴验证输出：测试结果、文件路径、检查命令等]

### 完成度检查
- [ ] 交付物存在且可访问
- [ ] 需求已完全覆盖
- [ ] 无已知缺口或缺陷
- [ ] 无回归（代码类）
- [ ] 角色视角已覆盖完整

### 决策
继续 / 停止
```

---

## 示例

### 示例 1：代码修复

**请求：** "登录返回 500 错误，帮我修复"

**迭代 1：**
- 理解需求：登录功能在特定场景返回 500，需要定位并修复
- 制定计划：1) 定位根因 2) 修复代码 3) 添加测试
- 执行：发现 user 可能为 undefined，添加空值检查
- 验证：运行登录测试，通过
- 完成度检查：基础场景通过，但过期 token 场景未测试
- 决策：继续

**迭代 2：**
- 补充边界测试，验证过期 token 场景
- 验证：所有测试通过
- 完成度检查：全部通过
- 决策：停止

### 示例 2：文档编写

**请求：** "为新 API 写一份使用文档"

**迭代 1：**
- 理解需求：API 文档需要包含概述、认证、端点说明、示例
- 执行：创建文档，包含基础说明和代码示例
- 验证：阅读检查，确认示例代码可复制
- 完成度检查：缺少错误处理说明，示例未验证可运行
- 决策：继续

**迭代 2：**
- 补充错误码说明和错误处理示例
- 运行示例代码，确保可执行
- 验证：文档完整，示例可运行
- 完成度检查：全部通过
- 决策：停止

### 示例 3：配置迁移

**请求：** "把旧配置格式迁移到新格式"

**迭代 1：**
- 理解需求：需要转换脚本和转换后的配置文件
- 执行：编写转换脚本，生成新配置
- 验证：语法检查通过
- 完成度检查：未实际加载测试，可能有问题
- 决策：继续

**迭代 2：**
- 使用新配置启动应用，确认无报错
- 对比新旧配置，确认无遗漏字段
- 验证：应用正常运行，功能无异常
- 完成度检查：全部通过
- 决策：停止

---

## 常见错误

### 流程违规

| 错误 | 后果 |
|------|------|
| 以"很简单"为由跳过迭代 | 容易遗漏边界情况 |
| 一次迭代后不检查就停止 | 可能未完全满足需求 |
| 无验证证据就宣称完成 | 无法确认质量 |
| 需求理解偏差就开始执行 | 返工不可避免 |
| 单一视角开展工作 | 遗漏关键关注点，产出有缺陷 |

### 迭代质量

| 错误 | 后果 |
|------|------|
| 每轮迭代无明确目标 | 效率低下 |
| 发现缺口但不记录就重复执行 | 容易遗漏问题 |
| 验证失败仍继续 | 产出有缺陷 |
| 引入新问题但不修复就声称完成 | 质量退化 |

---

## 借口 vs 事实

| 借口 | 事实 |
|------|------|
| "任务很简单，不需要迭代" | 简单也需要完成度检查；一过性执行容易遗漏 |
| "用户没要求迭代" | 有产出就默认迭代，无需明确要求 |
| "迭代太慢了" | 一次性返工比多次迭代更慢 |
| "我已经检查过了" | 每轮都必须重新评审，缺口可能累积 |
| "差不多行了" | 仅当全部完成条件满足时才能停止 |
| "缺信息先猜测" | 信息缺失必须询问，猜测导致返工 |

---

## 红旗 - 立即停止

以下行为违反迭代协议，必须立刻纠正：

- **跳过完成度检查**：执行后不验证就声称完成
- **无证据宣称完成**：无法证明交付物正确可用
- **带缺口停止**：明知有问题或遗漏仍声称完成
- **高风险未确认**：执行破坏性/不可逆操作前未征得同意
- **重复无效迭代**：不更新缺口清单就重复相同操作
- **单一视角工作**：未使用多角色分析即开始执行

---

## 高风险确认条件

触发以下情况时，必须在执行前明确获得用户批准：

- 破坏性或不可逆操作（删除数据、历史重写、覆盖文件）
- 安全、鉴权、敏感数据相关变更
- 可能破坏兼容性的变更
- 范围超出原计划且增加风险

---

## 项目特定扩展

项目可通过 `.ai/project-rules.md` 扩展本技能：

- 定义项目特定的验证方式
- 添加项目特定的完成检查项
- 配置项目高风险确认条件
- 定义项目特有的任务类型映射

---

## 精神内核

> **迭代不是流程，是本能。**

不是"用户要求我迭代"，而是"我迭代直到正确"。
不是"走完流程就行"，而是"真正完成才停止"。
不是"看起来做了"，而是"证明做好"。

这是你刻在骨子里的基因。
